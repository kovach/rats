.type RuleId = symbol
.type Id = Id { rule: RuleId, binding: Binding }
.type Entity = Id
.type Binding = Nil {}
              | Bind { val: Term, rest: Binding }
.type Term = TermPred { x: symbol }
           | TermId { x: Id }
           | TermNum { x: number }
.type Time = L { x: Term } | R { x: Term } | Top {}

.decl Val(ref: Term, val: Term) .output Val .input Val(rfc4180=true,delimiter=",")

.decl Lt(a: Time, b: Time)
.decl Le(a: Time, b: Time)
.decl Eq(a: Time, b: Time) eqrel
.decl IsId(x: Term)
Le(a,c) :- Le(a,b), Le(b,c).
Le(a,b) :- Lt(a,b).
Lt(a,c) :- Lt(a,b), Le(b,c).
Lt(a,c) :- Le(a,b), Lt(b,c).
Le(a,b) :- Eq(a,b).
Eq($L(a),$L(a)) :- IsId(a).
Eq($R(a),$R(a)) :- IsId(a).

Lt(a, $Top()) :- Lt(a, _).
Lt(a, $Top()) :- Lt(_, a).

.decl Contains(x: Term, y: Term)
.decl After(x: Term, y: Term)
Contains(a, b) :- IsId(a), IsId(b), Lt($L(a), $L(b)), Lt($R(b), $R(a)).
After(a, b) :- IsId(a), IsId(b), Lt($R(a), $L(b)).

// .decl move(id: Term, it: Term, to: Term)
// .decl MoveBefore(id: Term, it: Term, t: Time)
// .decl NotLast(id: Term, it: Term, t: Time)
// .decl Last(id: Term, it: Term, t: Time)
// .decl LastPosition(it: Term, at: Term, t: Time)
// .decl Nowhere(it: Term, t: Time) .output Nowhere
// .decl at(it: Term, at: Term, t: Time) .output at
// .decl move_at(move: Term, at: Term)
//
// MoveBefore(id, it, t) :- move(id, it, _), Le($R(id), t).
// NotLast(id1, it, t) :-
//   MoveBefore(id1, it, t),
//   MoveBefore(id2, it, t),
//   Lt($R(id1), $L(id2)).
// Last(id, it, t) :- MoveBefore(id, it, t), !NotLast(id, it, t).
// LastPosition(it, at, t) :- Last(id, it, t), move(id, _, at).
// at(it, at, t) :- t = $Top(), LastPosition(it, at, t), 1 = count : { LastPosition(it, _, t) }.
// Nowhere(it, t) :- t = $Top(), LastPosition(it, _, t), C = count : { LastPosition(it, _, t) }, C > 1.

.decl move(id: Term, it: Term, to: Term)
.decl MoveBefore(id: Term, it: Term, t: Time)
.decl NotLast(id: Term, it: Term, t: Time)
.decl Last(id: Term, it: Term, t: Time)
.decl LastPosition(it: Term, at: Term, t: Time)
.decl Nowhere(it: Term, t: Time) .output Nowhere
.decl at(id: Term) .output at
.decl at_pos(id: Term, it: Term, at: Term)
.decl move_at(move: Term, at: Term)

at(t), move_at(m, t), Eq($L(t), $R(m)) :- move(m, _, _), t=$TermId($Id("move_at", $Bind(m, $Nil()))).
at_pos(t, it, at) :- at(t), move_at(m, t), move(m, it, at).
MoveBefore(id, it, t) :- move(id, it, _), Le($R(id), t).
NotLast(id1, it, t) :-
  MoveBefore(id1, it, t),
  MoveBefore(id2, it, t),
  Lt($R(id1), $L(id2)).
Last(id, it, t) :- MoveBefore(id, it, t), !NotLast(id, it, t).
Lt($L(t), $R(at)) :- IsId(t), Last(move, it, t), move_at(move, at), at_pos(at, it, at).
Nowhere(it, t) :- t = $Top(), LastPosition(it, _, t), C = count : { LastPosition(it, _, t) }, C > 1.

.decl TotalT(points: number, eq: number, lt: number, le: number, contains_: number, after: number) .output TotalT
TotalT(points, eq, lt, le, cont, aft) :-
  le = count : Le(_, _),
  eq = count : Eq(_, _),
  lt = count : Lt(_, _),
  cont = count : Contains(_, _),
  aft = count : After(_, _),
  points = count : Le(_, $Top()).

// .output choose(rfc4180=true,delimiter=",")

// todo
//.decl AA(a: number)
//.decl AAA(a: Term)
//AA(autoinc()) :- Le(a,b).
//AAA($TermNum(a)) :- AA(a).
