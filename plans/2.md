# Plan: Reduce Cloning in rust-derp with Arc<Term>

## Current State

- `Term` is a 16-byte enum (largest variant: `App(Sym, Arc<[Term]>)`)
- `Tuple = SmallVec<[Term; 6]>` — cloning copies up to 96 bytes
- `Binding.entries: SmallVec<[(Sym, Term); 8]>` — cloning copies up to 160 bytes
- `Expr::Join(Box<Expr>, Box<Expr>)` — cloning does a deep copy of the expression tree
- `sub_term` returns `Term`, always clones even for unchanged subexpressions

## Key Insight

Even though individual `Term` clones are cheap (16 bytes), the *frequency* of
cloning in hot loops (specialize × eval × worklist) creates a multiplicative
cost. The bigger wins come from:

1. **`sub_term` can skip rebuilding unchanged `App` terms** — with `Arc<Term>`,
   we use `Arc::ptr_eq` to detect when no substitution happened and return the
   original Arc (zero allocation).
2. **Binding values become cheap to clone** — looking up a variable in a
   Binding returns an `Arc<Term>` clone (pointer + refcount) instead of copying
   the `Term`.
3. **Tuple cloning shrinks** — 6×8 bytes + 6 atomic increments instead of 6×16
   bytes.
4. **`Expr` cloning in specialize's Join handling** — a separate win via
   `Rc<Expr>`.

## Tradeoffs / Risks

- **Heap allocation per term**: every leaf term (`Var`, `Pred`, `Num`, `Str`,
  `Blank`) now needs a heap allocation to wrap in `Arc`. This adds allocator
  pressure.
- **Cache locality**: terms scattered on heap vs. inline in SmallVec. Could
  hurt iteration performance in HashSet lookups.
- **Atomic refcounting cost**: `Arc` uses atomic inc/dec. Since this program is
  single-threaded, `Rc` would be ~2x faster for refcounting. Consider a
  `type ATerm = Rc<Term>` alias so the choice is easy to flip later.
- **Double indirection in App**: `Arc<Term>` → `Term::App` → `Vec<Arc<Term>>`
  → `Arc<Term>`. More pointer chasing.

**Net assessment**: likely a win because the hot path (sub_term returning
unchanged ground terms) avoids allocation entirely, and Binding/Tuple clones
are very frequent. But should be benchmarked.

## Type Alias

Define once, use everywhere:

```rust
// types.rs
pub type ATerm = Arc<Term>;  // or Rc<Term> for single-threaded
```

This makes it easy to switch between `Arc` and `Rc` later.

---

## Phase 1: Type Definitions (types.rs)

### 1a. Add ATerm alias

```rust
pub type ATerm = Arc<Term>;
```

### 1b. Term::App

```rust
// Before:
App(Sym, Arc<[Term]>),

// After:
App(Sym, Vec<ATerm>),
```

Using `Vec<ATerm>` instead of `Arc<[ATerm]>` because:
- Individual args can be shared across different App terms
- sub_term can reuse unchanged arg Arcs
- The outer Term is already behind an Arc, so the Vec is shared too

### 1c. Tuple

```rust
// Before:
pub type Tuple = SmallVec<[Term; 6]>;

// After:
pub type Tuple = SmallVec<[ATerm; 6]>;
```

SmallVec<[ATerm; 6]> is 48 bytes inline (6 × 8-byte pointers) vs the old 96
bytes. Cloning now does 6 Arc clones instead of 6 Term copies.

### 1d. Binding

```rust
// Before:
pub entries: SmallVec<[(Sym, Term); 8]>,

// After:
pub entries: SmallVec<[(Sym, ATerm); 8]>,
```

All Binding methods update accordingly:
- `lookup` returns `Option<&ATerm>`
- `insert_sorted` takes `ATerm`
- `extend` takes `ATerm`
- `try_extend` takes `&ATerm`, compares with `existing == val` (Arc deref)
- `from_list` takes `&[(Sym, ATerm)]`

### 1e. Expr

```rust
// Before:
Bind(Term, Term),

// After:
Bind(ATerm, ATerm),
```

The `Atom(Tuple)` and `NegAtom(Tuple)` variants automatically pick up the
Tuple change.

### 1f. Helper: ATerm constructors

Add convenience functions:

```rust
pub fn avar(s: Sym) -> ATerm { Arc::new(Term::Var(s)) }
pub fn apred(s: Sym) -> ATerm { Arc::new(Term::Pred(s)) }
pub fn anum(n: i32) -> ATerm { Arc::new(Term::Num(n)) }
pub fn ablank() -> ATerm { Arc::new(Term::Blank) }
pub fn astr(s: Sym) -> ATerm { Arc::new(Term::Str(s)) }
pub fn aapp(cons: Sym, args: Vec<ATerm>) -> ATerm { Arc::new(Term::App(cons, args)) }
```

### 1g. Tuples methods

- `insert_tuple`: `tuple[0]` is now `&ATerm`, pattern match via `tuple[0].as_ref()`
- `contains_tuple`: same pattern-match change
- `pp`: `full.push(Arc::new(Term::Pred(*pred)))` or use `apred`
- `rest: Tuple = tuple[1..].into()` — this now clones Arc pointers, cheap

### 1h. pp methods

- `Term::pp` unchanged (takes `&self`)
- `pp_tuple` unchanged (iterates `&ATerm`, auto-derefs)

---

## Phase 2: Core Logic (core.rs)

### 2a. unify_term

```rust
// Before:
pub fn unify_term(b: &Binding, pat: &Term, val: &Term) -> Option<Binding>

// After:
pub fn unify_term(b: &Binding, pat: &ATerm, val: &ATerm) -> Option<Binding>
```

- Pattern match via `(pat.as_ref(), val.as_ref())`
- `Var` case: `b.try_extend(*var, val)` where try_extend now takes `&ATerm`
  and clones the Arc into the binding (cheap)
- `Pred/Num/Str` cases: compare via `pat == val` (Arc delegates to inner Eq)
- `App` case: recurse on arg pairs

### 2b. unify_tuples

```rust
// Before:
pub fn unify_tuples(b: &Binding, ts1: &[Term], ts2: &[Term]) -> Option<Binding>

// After:
pub fn unify_tuples(b: &Binding, ts1: &[ATerm], ts2: &[ATerm]) -> Option<Binding>
```

The body stays the same — it just iterates and calls unify_term.

### 2c. sub_term (the big win)

```rust
// Before:
pub fn sub_term(ctx: &Binding, t: &Term) -> Term

// After:
pub fn sub_term(ctx: &Binding, t: &ATerm) -> ATerm
```

Key optimization — reuse unchanged terms:

```rust
pub fn sub_term(ctx: &Binding, t: &ATerm) -> ATerm {
    match t.as_ref() {
        Term::Var(n) => ctx.lookup(*n).expect("unbound variable").clone(),
        Term::App(cons, args) => {
            let new_args: Vec<ATerm> = args.iter()
                .map(|a| sub_term(ctx, a))
                .collect();
            // If nothing changed, reuse original Arc (zero allocation!)
            if new_args.iter().zip(args.iter())
                .all(|(a, b)| Arc::ptr_eq(a, b))
            {
                t.clone()   // just bump refcount
            } else {
                Arc::new(Term::App(*cons, new_args))
            }
        }
        Term::Blank => panic!("cannot substitute blank"),
        _ => t.clone(),  // Pred/Num/Str: just bump refcount, no copy
    }
}
```

This is the biggest single win. For ground terms (no variables), sub_term is
now O(1) — just an Arc clone. Previously it would clone the entire term.

### 2d. subst / substs

Same signature changes (work with ATerm in Tuple), body stays the same.

### 2e. specialize

Mechanical update:
- `unify_tuples` call now passes `&[ATerm]` slices
- Everything else flows from the type changes

### 2f. eval

- `Expr::Bind(x, y)`: `sub_term` now takes `&ATerm`
- `Expr::Atom(pat)`: pat elements are `ATerm`, slicing gives `&[ATerm]`
- eval_builtin_str: pattern match via `.as_ref()`, `Term::Num` extraction same
- range builtin: `unify_term(b, t, &Arc::new(Term::Num(i)))` (or `&anum(i)`)

### 2g. iter (worklist)

The triple-clone on lines 310-313 now clones Tuples containing Arc<Term>
instead of Term. Each Tuple clone is 6 Arc clones (6 atomic increments, 48
bytes) instead of 6 Term copies (96 bytes).

No structural change needed — just flows from the Tuple type change.

---

## Phase 3: Parser (parse.rs)

### 3a. term()

Every place the parser constructs a Term, wrap in Arc::new() or use the
helpers:

```rust
// Before:
Ok(Term::App(sym, args.into()))
// After:
Ok(Arc::new(Term::App(sym, args)))

// Before:
Ok(Term::Pred(sym))
// After:
Ok(Arc::new(Term::Pred(sym)))
```

The parser's `term()` method returns `PResult<ATerm>` instead of
`PResult<Term>`.

### 3b. tuple()

Returns `PResult<Tuple>` — unchanged since Tuple now contains ATerm and the
terms from the parser are already ATerm.

### 3c. expr_leaf()

- `Expr::Bind(lhs, rhs)` — lhs and rhs are already ATerm from `term()`
- `Expr::NegAtom(tuple)` — tuple contains ATerm, works
- `atom(tuple)` — works

### 3d. No changes to rule(), prog(), or parse()

These compose the lower-level parsers and don't touch Term directly.

---

## Phase 4: Bonus — Rc<Expr> for Join (optional, separate PR)

This is independent of Arc<Term> but addresses another major clone hotspot.

```rust
// Before:
Join(Box<Expr>, Box<Expr>),

// After:
Join(Rc<Expr>, Rc<Expr>),
```

**Why**: In specialize (core.rs:112-141), the Join handler clones `a_expr`
and `b_expr` up to 3× per iteration. With `Box`, each clone deep-copies the
entire Expr subtree. With `Rc`, it's a pointer bump.

Changes needed:
- `join()` helper wraps in `Rc::new()` instead of `Box::new()`
- `specialize` and `eval` dereference via `.as_ref()` (same as Box)
- `Closure` cloning is cheaper since Expr clone becomes Rc clones

This is a bigger win than it looks: the "d(a)·b + a·d(b) + d(a)·d(b)"
expansion in specialize means Expr trees get cloned *combinatorially*.

---

## Implementation Order

1. **Phase 1**: types.rs — add ATerm alias, change all type definitions
2. **Phase 2**: core.rs — update all functions (guided by compiler errors)
3. **Phase 3**: parse.rs — wrap constructed terms in Arc::new()
4. **Test**: run against existing .derp files, verify identical output
5. **Benchmark**: compare perf before/after with `perf record`
6. **Phase 4** (optional): Rc<Expr> for Join, benchmark again

Each phase should compile before moving to the next (the compiler will guide
you through the required changes).

---

## Expected Outcome

- **sub_term on ground terms**: O(1) instead of O(size_of_term)
- **Binding clone**: ~96 bytes + 8 atomic ops instead of ~160 bytes memcpy
- **Tuple clone**: ~48 bytes + 6 atomic ops instead of ~96 bytes memcpy
- **Worklist triple-clone**: 3× cheaper per tuple
- **Net**: significant reduction in allocator and memcpy pressure in the hot
  loop. Exact improvement depends on term complexity and rule structure.
