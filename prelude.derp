eq A B -- eq B A.
eq A B -- le A B, le B A.
eq A B, eq B C -- eq A C.
lt A B -- le A B.
le A B, le B C -- le A C.
le A B, lt B C -- lt A C.
lt A B, le B C -- lt A C.
lt A A -- zzz A.

; move : id / it / to
move Id It _, lt r(Id) T
---
moveBefore Id It T.

moveBefore I1 It T, moveBefore I2 It T, lt r(I1) l(I2)
---
notLast I1 It T.

moveBefore I It T, !notLast I It T
----------------------------------
last I It T.

move M It At, NewId = id("at", bind(M, nil()))
----------------------------------------------
isId NewId, at NewId It At, move_at M NewId, eq l(NewId) r(M).

isId T, last Move _ l(T), move_at Move Id
--------------------------------------
lt l(T) r(Id).

; ?turn / âˆƒchoice ?C.
; ->
; turn T, CHOICE = id(...), C = choice(id(...))
; --
; try choice(CHOICE, C).
; split separate rule, so base rule is simpler?

; try choice(CH, ...), !chose(CH)
; ---
; choice CH ....
