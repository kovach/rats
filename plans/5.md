# Plan: Store pred Sym directly in CExpr::Atom

## Context
`CExpr::Atom` strips the pred during compilation but needs it at eval time for `tuples.lookup()`. Currently this is solved with a side-channel: `remaining_preds` (a flat vec of pred Syms) and a `pred_idx` counter threaded through `eval_compiled`. This also requires `count_atoms` to manage the index across Join nodes. Storing the pred directly in the node eliminates all of this.

## Changes

### `types.rs`
- `CExpr::Atom(Vec<CTerm>)` → `CExpr::Atom(Sym, Vec<CTerm>)` — pred sym as first field
- Remove `remaining_preds: Vec<Sym>` from `CSpecEntry`

### `core.rs` — `compile_expr`
- Extract pred Sym from `pat[0]` and include it: `CExpr::Atom(sym, cterms)`

### `core.rs` — `eval_compiled`
- Remove `pred_syms` and `pred_idx` parameters entirely
- `CExpr::Atom(pred, pat)` — use `pred` directly for `tuples.lookup(pred)`
- `CExpr::Join` — just recurse on a and b, no index arithmetic

### `core.rs` — delete functions
- `count_atoms`
- `collect_atom_preds`

### `core.rs` — `prespecialize`
- Remove `collect_atom_preds` call and `remaining_preds` from `CSpecEntry` construction

### `core.rs` — `eval1_spec`
- Remove `pred_idx`, call `eval_compiled` without `pred_syms`/`pred_idx`

## Verification
- `cargo run --release -- benches/data/test_simple.derp` → 9 tuples
- `cargo run --release -- benches/data/test_negation.derp` → 18 tuples
- `cargo run --release -- benches/data/out.derp` → 1828 tuples
