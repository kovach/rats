# Replace Sym with Name in Term enum + serde_json migration

## Context

The `Term` enum uses `Sym` (interned symbols) for all name fields, which ties terms to the `Interner`. By switching to a `Name` enum that can hold either `Sym` or `String`, we can resolve all names in a separate pass, producing terms with no `Sym` references — enabling `#[derive(Serialize)]` for JSON output.

## Part 1: Replace Sym with Name in Term

### 1a. Term enum (`types.rs:41-48`)

Change:
```rust
pub enum Term {
    Var(Name),    // was Sym
    Pred(Name),   // was Sym
    Num(i32),
    Blank,
    App(Name, Vec<ATerm>),  // was Sym
    Str(Name),    // was Sym
}
```

### 1b. Helper functions (`types.rs:26-31`)

Change parameter types from `Sym` to `Name`:
```rust
pub fn avar(s: Name) -> ATerm { ... }
pub fn apred(s: Name) -> ATerm { ... }
pub fn astr(s: Name) -> ATerm { ... }
pub fn aapp(cons: Name, args: Vec<ATerm>) -> ATerm { ... }
```

### 1c. Fix parse.rs call sites

Every place that does `let sym = self.intern.intern(&name); Ok(avar(sym))` etc. wraps in `Name::Sym(...)`:
- Line 231: `aapp(Name::Sym(sym), args)`
- Line 236: `apred(Name::Sym(sym))`
- Line 244: `avar(Name::Sym(sym))`
- Line 259: `avar(Name::Sym(sym))`
- Line 276: `astr(Name::Sym(sym))`

### 1d. Fix pattern matches in types.rs

**`pp` and `to_json` methods**: Add a local helper or match through `Name::Sym(s)` to resolve. For `pp`:
```rust
Term::Var(Name::Sym(s)) => i.resolve(*s).to_owned(),
// etc.
```
Add a wildcard or `Name::Str` arm too so matches are exhaustive.

**`insert_tuple` / `contains_tuple`** (lines 104, 124): These extract a `Sym` for HashMap keys. Match through to get the Sym:
```rust
Term::Pred(Name::Sym(p)) => *p,
```

**`apred(*pred)` call on line 180**: Wrap: `apred(Name::Sym(*pred))`

### 1e. Fix pattern matches in core.rs

**`unify_term` (lines 10-29)**: Match `Term::Var(Name::Sym(var))`, `Term::App(Name::Sym(cons1), ...)`, etc.

**`sub_term` (lines 45-59)**:
- `Term::Var(Name::Sym(n)) => ctx.lookup(*n)...`
- `Term::App(Name::Sym(cons), args) => ... aapp(Name::Sym(*cons), new_args)`

**`eval` Pred extraction (lines 172-189)**: `Term::Pred(Name::Sym(p)) => ...`

**`chk_str` / builtin matching (lines 241+)**: `Term::App(Name::Sym(cons), _) => ...`

## Part 2: Name traversal functions (`types.rs`)

Two functions that recursively traverse a term tree:

```rust
impl Term {
    /// Resolve all Name::Sym → Name::Str using the interner
    pub fn resolve_names(&self, i: &Interner) -> Term { ... }

    /// Intern all Name::Str → Name::Sym using the interner
    pub fn intern_names(&self, i: &mut Interner) -> Term { ... }
}
```

Each recursively maps over the term, converting the Name in each variant. `App` additionally recurses into its child terms.

## Part 3: Updated serde_json plan

With `resolve_names`, a Term contains only `Name::Str(String)` — no Sym references. This means we can:

1. Add `serde = { version = "1", features = ["derive"] }` and `serde_json = "1"` to Cargo.toml
2. `#[derive(Serialize)]` on `Name` (skip the `Sym` variant or mark it as error)
3. `#[derive(Serialize)]` on `Term` with serde tag attributes for the tagged union format
4. In `Tuples::to_json`, call `resolve_names` on each term before serializing
5. Delete `json_escape` and the manual `to_json` methods

This is a cleaner approach than the original plan since we get derive-based serialization instead of manual `json!()` calls.

## Files to modify

- `rust-derp/src/types.rs` — Term enum, helpers, Name impl, pp/to_json, Tuples methods
- `rust-derp/src/parse.rs` — wrap intern results in Name::Sym
- `rust-derp/src/core.rs` — pattern match updates
- `rust-derp/Cargo.toml` — serde deps (Part 3 only)

## Verification

1. `cargo build --release` in `rust-derp/` after Part 1+2
2. Run pipeline, diff `out.tuples` — should be identical since we only change internals
3. After Part 3 (serde), diff again — JSON content equivalent, key order may differ
