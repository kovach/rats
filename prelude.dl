// .output choose(rfc4180=true,delimiter=",")

.type RuleId = symbol
.type Id = Id { rule: RuleId, binding: Binding }
.type Entity = Id
.type Binding = Nil {}
              | Bind { val: Term, rest: Binding }
.type Term = TermPred { x: symbol }
           | TermId { x: Id }
           | TermNum { x: number }
.type Time = L { x: Term } | R { x: Term }
           | Max { a: Time, b: Time }
           | Min { a: Time, b: Time }
           | Top {}

.decl Val(ref: Term, val: Term) .output Val .input Val(rfc4180=true,delimiter=",")

.decl lt(a: Time, b: Time)
.decl le(a: Time, b: Time)
.decl eq(a: Time, b: Time) eqrel
.decl isId(x: Term)
.decl occurs(t: Time)
le(a,c) :- le(a,b), le(b,c).
le(a,b) :- lt(a,b).
lt(a,c) :- lt(a,b), le(b,c).
lt(a,c) :- le(a,b), lt(b,c).
le(a,b) :- eq(a,b).
eq($L(a), $L(a)) :- isId(a).
eq($R(a), $R(a)) :- isId(a).
lt($L(a), $R(a)) :- isId(a).
lt($R(a), $Top()) :- isId(a).
occurs(a), occurs(b) :- eq(a,b).
occurs(a), occurs(b) :- lt(a,b).
occurs(a), occurs(b) :- le(a,b).
occurs(a), occurs(b) :- occurs($Min(a,b)).
occurs(a), occurs(b) :- occurs($Max(a,b)).

// max(a,b) < x <--> a < x && b < x (all comparable)
lt(x, $Min(a,b)) :- occurs($Min(a,b)), lt(x,a), lt(x,b).
lt($Max(a,b), x) :- occurs($Max(a,b)), lt(a,x), lt(b,x).

// x < max(a,b) <--> x < a || x < b (exists comparable)
lt(x, $Max(a,b)) :- occurs($Max(a,b)), (lt(x,a) ; lt(x,b)).
lt($Min(a,b), x) :- occurs($Min(a,b)), (lt(a,x) ; lt(b,x)).

.decl TotalT(points: number, eq: number, lt: number, le: number, contains_: number, after: number, occurs: number) .output TotalT
TotalT(points, eq, lt, le, cont, aft, occ) :-
  le = count : le(_, _),
  eq = count : eq(_, _),
  lt = count : lt(_, _),
  cont = count : cont(_, _),
  aft = count : after(_, _),
  occ = count : occurs(_),
  points = count : le(_, $Top()).

.decl move(id: Term, it: Term, to: Term)
.decl moveBefore(id: Term, it: Term, t: Time)
.decl last(id: Term, it: Term, t: Time)
.decl lastPosition(it: Term, at: Term, t: Time)
//.decl at(id: Term)
//.decl atPos(id: Term, it: Term, at: Term)
.decl at(id: Term, it: Term, at: Term)
.decl move_at(move: Term, id: Term)
.decl nowhere(it: Term, t: Time) .output nowhere

moveBefore(id, it, t) :- move(id, it, _), le($R(id), t).
last(id, it, t) :- moveBefore(id, it, t).
last(id1, it, t) <= last(id2, it, t) :- lt($R(id1), $L(id2)).

lastPosition(it, at, t) :- last(id, it, t), move(id, _, at).
nowhere(it, t) :-  lastPosition(it, _, t), C = count : { lastPosition(it, _, t) }, C > 1.

isId(id), at(id, it, at), move_at(m, id), eq($L(id), $R(m)) :- move(m, it, at), id = $TermId($Id("at", $Bind(m, $Nil()))).
// atPos(id, it, at) :- at(id), move_at(m, id), move(m, it, at).
lt($L(t), $R(id)) :- isId(t), last(move, _, $L(t)), move_at(move, id).

.decl overlap(a: Term, b: Term)
.decl cont(a: Term, b: Term)
.decl after(a: Term, b: Term)
cont(a, b)    :- lt($L(a), $L(b)), lt($R(b), $R(a)).
after(a, b)   :- lt($R(a), $L(b)).
overlap(a, b) :- lt($L(a), $R(b)), lt($L(b), $R(a)).

.decl out(move: Term, visible: Term) .output out
out(a, b) :- visible(_, a, b).

//lt($Top(), $Top()) :- x = count : { at(x, y, z) }.
//.decl asdf(x: number)
//asdf(X+1) :- asdf(X)
//asdf(X) <= asdf(Y) :- X < Y.
