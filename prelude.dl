// .output choose(rfc4180=true,delimiter=",")

.type RuleId = symbol
.type Id = Id { rule: RuleId, binding: Binding }
.type Entity = Id
.type Binding = Nil {}
              | Bind { val: Term, rest: Binding }
.type Term = TermPred { x: symbol }
           | TermId { x: Id }
           | TermNum { x: number }
.type Time = L { x: Term } | R { x: Term } | Top {}

.decl Val(ref: Term, val: Term) .output Val .input Val(rfc4180=true,delimiter=",")

.decl lt(a: Time, b: Time)
.decl le(a: Time, b: Time)
.decl eq(a: Time, b: Time) eqrel
.decl isId(x: Term)
le(a,c) :- le(a,b), le(b,c).
le(a,b) :- lt(a,b).
lt(a,c) :- lt(a,b), le(b,c).
lt(a,c) :- le(a,b), lt(b,c).
le(a,b) :- eq(a,b).
eq($L(a), $L(a)) :- isId(a).
eq($R(a), $R(a)) :- isId(a).
lt($L(a), $R(a)) :- isId(a).
lt($R(a), $Top()) :- isId(a).

.decl TotalT(points: number, eq: number, lt: number, le: number, contains_: number, after: number) .output TotalT
TotalT(points, eq, lt, le, cont, aft) :-
  le = count : le(_, _),
  eq = count : eq(_, _),
  lt = count : lt(_, _),
  cont = count : cont(_, _),
  aft = count : after(_, _),
  points = count : le(_, $Top()).

.decl move(id: Term, it: Term, to: Term)
.decl moveBefore(id: Term, it: Term, t: Time)
.decl last(id: Term, it: Term, t: Time)
.decl lastPosition(it: Term, at: Term, t: Time)
//.decl at(id: Term)
//.decl atPos(id: Term, it: Term, at: Term)
.decl at(id: Term, it: Term, at: Term)
.decl move_at(move: Term, id: Term)
.decl nowhere(it: Term, t: Time) .output nowhere

moveBefore(id, it, t) :- move(id, it, _), le($R(id), t).
last(id, it, t) :- moveBefore(id, it, t).
last(id1, it, t) <= last(id2, it, t) :- lt($R(id1), $L(id2)).

lastPosition(it, at, t) :- last(id, it, t), move(id, _, at).
nowhere(it, t) :-  lastPosition(it, _, t), C = count : { lastPosition(it, _, t) }, C > 1.

isId(id), at(id, it, at), move_at(m, id), eq($L(id), $R(m)) :- move(m, it, at), id = $TermId($Id("at", $Bind(m, $Nil()))).
// atPos(id, it, at) :- at(id), move_at(m, id), move(m, it, at).
lt($L(t), $R(id)) :- isId(t), last(move, it, $L(t)), move_at(move, id).

.decl overlap(a: Term, b: Term)
.decl cont(a: Term, b: Term)
.decl after(a: Term, b: Term)
cont(a, b)    :- lt($L(a), $L(b)), lt($R(b), $R(a)).
after(a, b)   :- lt($R(a), $L(b)).
overlap(a, b) :- lt($L(a), $R(b)), lt($L(b), $R(a)).

.decl out(move: Term, visible: Term) .output out
out(m, a) :- isId(a), move_at(m, b), a != b, overlap(a,b).
