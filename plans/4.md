# Plan: Precompute Query Specialization

## Context
Currently, `eval1` calls `specialize_` at runtime for every `(rule, tuple)` pair. `specialize_` pattern-matches the tuple against atoms in the rule body, producing specialized closures. This is redundant work — the set of predicate names that appear as atoms in rule bodies is known statically. We can precompute specialization once, up front, keyed by predicate symbol, and look up the results during iteration.

The key challenge: `specialize_` currently takes a concrete `Tuple` (with ground terms), but for precomputation we need to specialize against a *symbolic* tuple — one whose predicate is known but whose arguments are fresh variables.

## Design

### Core idea
For each rule, and for each predicate `p` that appears as an `Atom` in that rule's body, generate a symbolic tuple `[Pred(p), Var(fresh1), Var(fresh2), ...]` with the right arity, and run `specialize_` with it. The result is a set of `(Binding, Expr)` pairs where the binding maps fresh variables to positions in the incoming tuple. At runtime, `eval1` just looks up the precomputed specializations by predicate and unifies the fresh vars with the actual tuple values.

### Step 1: Collect predicate signatures from rule bodies

Add a function `atom_predicates(expr: &Expr) -> Vec<(Sym, usize)>` that walks an `Expr` and returns all `(predicate_sym, arity)` pairs from `Atom` nodes. The predicate is `pat[0]` (always a `Pred`), arity is `pat.len() - 1`.

**File:** `rust-derp/src/core.rs`

### Step 2: Define `SpecializedRule`

A struct holding the precomputed result of specializing a rule against a predicate:

```rust
pub struct SpecializedRule {
    pub ctx: Binding,       // bindings established during specialization
    pub val: Expr,          // remaining expression after specialization
    pub fresh_vars: Vec<Sym>, // fresh variable syms corresponding to tuple positions
    pub head: Vec<Tuple>,   // from the original rule, for producing output
}
```

Actually, since `specialize_` can produce *multiple* results (the three Join strategies), we need a vec:

```rust
pub struct SpecEntry {
    pub ctx: Binding,
    pub val: Expr,
    pub fresh_vars: Vec<Sym>,
}

pub struct SpecializedRule {
    pub entries: Vec<SpecEntry>,
    pub head: Vec<Tuple>,
}
```

**File:** `rust-derp/src/types.rs`

### Step 3: Build symbolic tuples and run specialization

Add a function `prespecialize`:

```rust
pub fn prespecialize(
    rules: &[Rule],
    intern: &mut Interner,
) -> HashMap<Sym, Vec<SpecializedRule>>
```

For each non-immediate rule:
1. Call `atom_predicates` on the rule body to get all `(pred, arity)` pairs
2. For each `(pred, arity)`:
   - Generate fresh variable names like `__spec0`, `__spec1`, ... and intern them
   - Build symbolic tuple: `[Pred(pred), Var(__spec0), Var(__spec1), ...]`
   - Call `specialize_(&mut rule.body.ctx.clone(), &rule.body.val, &symbolic_tuple, callback)`
   - Collect all `(ctx, expr)` results, paired with the fresh var syms
3. Store in a `HashMap<Sym, Vec<SpecializedRule>>` keyed by predicate

**File:** `rust-derp/src/core.rs`

### Step 4: New `eval1_spec` that uses precomputed specializations

```rust
pub fn eval1_spec(
    specs: &[SpecializedRule],
    t: &Tuple,  // concrete tuple (without pred prefix — just the args)
    ts: &Tuples,
    check: &Tuples,
    intern: &Interner,
) -> Vec<Binding>
```

For each `SpecEntry` in the specialization:
1. Clone the precomputed `ctx`
2. Bind each `fresh_var[i]` to `t[i]` (the concrete tuple args)
3. Call `eval_` on the precomputed `val`
4. Collect bindings

**File:** `rust-derp/src/core.rs`

### Step 5: Update `iter_rules` to use precomputed specializations

In `iter_rules`, after partitioning rules:
1. Call `prespecialize(&rest, intern)` to build the lookup table
2. Change the closure `f` to:
   - Extract the predicate `Sym` from `t[0]`
   - Look up `specs[pred]`
   - For each `SpecializedRule`, call `eval1_spec` instead of `step_rule`

**File:** `rust-derp/src/core.rs`

### Files to modify
- `rust-derp/src/types.rs` — add `SpecEntry`, `SpecializedRule` structs
- `rust-derp/src/core.rs` — add `atom_predicates`, `prespecialize`, `eval1_spec`; update `iter_rules`

## Verification
1. `cargo check` — compiles
2. `cargo bench` — compare timing before/after
3. Run `cargo run --release -- test_simple.derp` and `cargo run --release -- ../test.derp` — output should be identical to before
